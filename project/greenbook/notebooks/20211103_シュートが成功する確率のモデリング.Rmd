---
title: "シュートが成功する確率のモデリング"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r install_package, include=FALSE}
# パッケージの読み込み
library(tidyverse)
library(magrittr)
library(ggplot2)
```

# やりたいこと

得点の確率をモデリングする
- 選手ごとに、N回シュートをうったら、得点した回数がy回、得点できなかった回数がN-y回

```{r}
data <- read_csv('../data/nba/processed/player_stats_1992_fixed_pos.csv')

# 観測されたデータ数
length(data) 

# データの要約
summary(data)
```

```{r}
# FG数の確認
ggplot(data = data) +
    geom_point(aes(x=MP, y=FG, colour=pos))

# FGごとのプレーヤー数
ggplot(data = data) +
    geom_histogram(aes(x=FG, fill=pos))
```


```{r}
# ロジスティック回帰を見てみる
logistic <- function(z){
    1 / (1 + exp(-z))
}

z <- seq(-6, 6, 0.1)
plot(z, logistic(z), type = 'l')
```

```{r}
# ロジスティック回帰
fit1 <- glm(cbind(FG, FGA - FG) ~ 1, data = data, family = binomial)
fit2 <- glm(cbind(FG, FGA - FG) ~ MP, data = data, family = binomial)
fit3 <- glm(cbind(FG, FGA - FG) ~ MP + pos, data = data, family = binomial)

summary(fit1)
summary(fit2)
summary(fit3)

# オッズ比の確認(fit3のモデルの場合)

## SGの場合
exp(5.816e-01) * exp(-6.570e-02)

## 他の条件が同じとき、SFに比べてSGだとオッズ比がどれだけ変わるか
exp(-1 * -3.515e-02) * exp(-6.570e-02)

## 他の条件が同じとき、Cに比べてSGだとオッズ比がどれだけ変わるか
exp(-6.570e-02)
```

予測を確認する

```{r}
# ロジスティック回帰(交互作用項を追加したモデル)
fit4 <- glm(cbind(FGA, FGA - FG) ~ MP * pos, data = data, family = binomial)

summary(fit4)
```

AICは向上しているものの、これは偽の交互作用で辻褄を合わせている可能性がある。

```{r}
plot_mp_pos <- function(fit, main = NA) {
	plot(data$MP, data$FG, type = "n", main = NA, xlab = "", ylab = "")
    
    xx <- seq(min(data$MP), max(data$MP), 1)

	# Cの予測可視化
	ff <- factor("C", levels = c('C', 'PF', 'PG', 'SF', 'SG'))
	N <- as.integer(mean(data$FGA))
	q <- predict(fit, newdata = data.frame(MP = xx, pos = ff), type = "response")
	lines(xx, q * N, lwd = 3)
    	
    # PFの予測可視化
	ff <- factor("PF", levels = c('C', 'PF', 'PG', 'SF', 'SG'))
	N <- mean(data$FGA)
	q <- predict(fit, newdata = data.frame(MP = xx, pos = ff), type = "response")
	lines(xx, q * N, col = "gray", lwd = 3)
	
    # SFの予測可視化
	ff <- factor("SF", levels = c('C', 'PF', 'PG', 'SF', 'SG'))
	N <- mean(data$FGA)
	q <- predict(fit, newdata = data.frame(MP = xx, pos = ff), type = "response")
	lines(xx, q * N, col = "blue", lwd = 3)
	
	# SGの予測可視化
	ff <- factor("SG", levels = c('C', 'PF', 'PG', 'SF', 'SG'))
	N <- mean(data$FGA)
	q <- predict(fit, newdata = data.frame(MP = xx, pos = ff), type = "response")
	lines(xx, q * N, col = "red", lwd = 3)
	
	# PG
	ff <- factor("PG", levels = c('C', 'PF', 'PG', 'SF', 'SG'))
	N <- mean(data$FGA)
	q <- predict(fit, newdata = data.frame(MP = xx, pos = ff), type = "response")
	lines(xx, q * N, col = "green", lwd = 3)
}
plot_mp_pos(fit3)
plot_mp_pos(fit4)
```

これは、`r as.integer(mean(data$FGA))`回シュートをうったと仮定したときの、成功本数を表している。


# シュート成功率を調べる

目的：選手iにおける、FG%が、ポジションの違いにどう影響されているのかを知りたい

- 選手ごとに、シュートアテンプト数が異なっている
- アテンプトがゼロなら、それは欲しい情報を持っていないので、データを除外するのが良さそう。https://stats.stackexchange.com/questions/136037/modelling-count-data-where-offset-variable-is-0-for-some-observations
    - 変数変換をする前に、データの意味を考えないといけない。

```{r}
data_has_shooted <- data %>% 
    filter(FGA > 0)

fit5 <- glm(FG ~ pos, offset = log(FGA), family = poisson, data = data_has_shooted)
summary(fit5)
```

FG数平均は、FGAに比例するといった過程を反映させつつ、ポジションの効果を推定できる。

# 選手の身長と体重の関係

```{r}
data_physical <- data %>% 
    filter(!is.na(weight_in_kg) & !is.na(height_in_cm))

ggplot(data_physical) +
    geom_point(aes(x=weight_in_kg, y=height_in_cm))

fit6 <- glm(height_in_cm ~ weight_in_kg, family = Gamma(link = 'log'), data = data)

summary(fit6)
```

```{r}

# 可視化
sum.fit <- summary(fit6)
vc <- sum.fit$coefficients[,"Estimate"]

names(vc) <- c("b1", "b2")
phi <- sum.fit$dispersion # dispersion parameter
sink("glm.txt")
print(sum.fit)
sink()

width  <- 4 # inch
height <- 3 # inch

get.y.mean <- function(b1, b2, x) exp(b1 + b2 * log(x))
plot.d <- function(tline = TRUE)
{
	plot(data$weight_in_kg, data$height_in_cm, xlab = "", ylab = "") 
	if (tline) {
		lines(data$weight_in_kg, get.y.mean(vc[["b1"]], vc[["b2"]], data$weight_in_kg), lty = 2, lwd = 2)
	}
}

# 帯の可視化準備
m <- get.y.mean(vc["b1"], vc["b2"], data$weight_in_kg)
rate <- 1 / (phi * m)
shape <- 1 / phi
plot.pi <- function(q) polygon(
	c(data$weight_in_kg, rev(data$weight_in_kg)),
	c(qgamma(q, shape, rate), rev(qgamma(1 - q, shape, rate))),
	border = NA,
	col = "#00000020"
)

# 可視化1
plot.d() +

# 可視化2
plot.d(FALSE) +
lines(data$weight_in_kg, get.y.mean(-1.3, 0.5, data$weight_in_kg), lty = 1, lwd = 2, col = "#808080") +
lines(data$weight_in_kg, get.y.mean(-0.5, 2, data$weight_in_kg), lty = 1, lwd = 2, col = "#808080") +
text(0.4, 0.4, "?", cex = 10, col = "#808080") +

# 可視化3
plot.d() +
lines(data$weight_in_kg, predict(fit6, newdata = data.frame(weight_in_kg = data$weight_in_kg), type = "response"), lwd = 2) +
plot.pi(q = 0.05) +
plot.pi(q = 0.25) +
# median
lines(data$weight_in_kg, qgamma(0.5, shape, rate), col = "#808080", lwd = 2)


```

# 一般化線形混合モデルで個体差を加味する(glmmmlパッケージ)

```{r, include = FALSE}
library(glmmML)
```



```{r}
data <- data %>% 
    mutate(id = row_number())

# ロジスティック回帰
fit_glmmml <- glmmML(cbind(FG, FGA - FG) ~ MP + pos, data = data, family = binomial, cluster = id, method = 'ghq')

summary(fit_glmmml)
```

# 一般化線形混合モデルで個体差を加味する(lme4パッケージ)

```{r, include = FALSE}
library(lme4)
```

```{r}
data <- data %>% 
    mutate(id = row_number())

# ロジスティック回帰
fit_glmer <- glmer(cbind(FG, FGA - FG) ~ MP + pos + (1|id), data = data, family = binomial)
    
summary(fit_glmer)
```

# 疑問点

## glmmml とlme4 のAICが違う

glmmmlのみ、他のものとAICの計算が違う？
lme4は、glmと同じ計算方法を使っている？

いかに書いてあるやつ。

[生態学データ解析 - glmmML 紹介](https://kuboweb.github.io/-kubo/ce/IntroductionGlmmML.html#toc2)
[過分散データ：GLM負の二項分布、GLMMによる推定をAICでモデル選択することは可能か？](http://nhkuma.blogspot.com/2014/02/glmglmmaic.html)

lme4のAICの計算方法が当時と変わっているっぽい。
本来、データの特性に合わせてモデル選択するので、glmとglmmmlは比較する必要はない?
glmとglmmmlを使った場合は、比較できないか、やり方がかなりめんどくさい(glmmmlはdeviance/loglikを返してくれないかつ、返してくれるdevianceが計算方法多分違う)
lme4の方を使っといた方が、基本は無難な気がする。


## 二項分布を使ったglmで、目的変数を y ~ と指定する場合と、cbind(y, N-y) ~ で指定する場合の違い?

確かめてないが、以下の違いだと憶測している
y ~ → yが2値の場合
cbind → yが成功回数の場合

## GLMMパッケージとlme4パッケージとの比較

[GLMMをRで実行する方法 | Sunny side up!](https://norimune.net/2365)

- アルゴリズムが異なることによる推定精度の違い
- 指定できる変量効果の個数違い


